/**
 *
 * Version : $Id$
 * This file was generated by Aldebaran Robotics ModuleGenerator
 */

#include "onredballdetection.h"

#include <alvalue/alvalue.h>
#include <alcommon/alproxy.h>
#include <alcommon/albroker.h>
#include <althread/alcriticalsection.h>
#include <vector>
#include <math.h>
#include <almath/tools/altrigonometry.h>


#include <alproxies/alrobotpostureproxy.h>
#include <alproxies/almotionproxy.h>

#include <qi/log.hpp>

using namespace std;

OnRedBallDetection::OnRedBallDetection(
    boost::shared_ptr<AL::ALBroker> broker,
    const std::string& name): AL::ALModule(broker, name),
    fMemoryProxy(getParentBroker()),
    ballCounter(0),
    motionProxy(getParentBroker()),
    ballProxy(getParentBroker()),
    fCallbackMutex(AL::ALMutex::createALMutex())
{
  setModuleDescription("Módulo para seguimiento de bola roja y translación del robot NAO");
}

OnRedBallDetection::~OnRedBallDetection() {
    ballProxy.stopTracker();

}

void OnRedBallDetection::init() {
    //boost::shared_ptr<AL::ALMotionProxy> proxy = getParentBroker()->getMotionProxy();

    // We use the "Body" name to signify the collection of all joints
    const std::string names = "Body";
    float stiffnessLists = 1.0f;
    float timeLists      = 1.0f;

    // the interpolation command will assume that the same value is desired
    // for all joints in the collection "Body"
    motionProxy.stiffnessInterpolation(names, stiffnessLists, timeLists);

    // Enable arm control by Walk algorithm
    motionProxy.setWalkArmsEnabled(true, true);

    // Enable FOOT CONTACT PROTECTION
    motionProxy.setMotionConfig(AL::ALValue::array(
       AL::ALValue::array("ENABLE_FOOT_CONTACT_PROTECTION", true)));

    // print motion state
    std::cout << motionProxy.getSummary() << std::endl;
    boost::shared_ptr<AL::ALRobotPostureProxy> posture_proxy =
    getParentBroker()->getSpecialisedProxy<AL::ALRobotPostureProxy>("ALRobotPosture");

    std::string posture = "Crouch";
    float maxSpeedFraction = 0.3f;

    posture_proxy->applyPosture(posture, maxSpeedFraction);

    posture = "StandInit";
    maxSpeedFraction = 0.2f;
    posture_proxy->applyPosture(posture, maxSpeedFraction);

    ballProxy.setWholeBodyOn(false);
 //   ballProxy.startTracker();

    std::string side = "Right";
    // We can modify this to make single reach.
    //while(1){
   //    reachBall();
       wbKick(side);
    //}

    //check_position();
}
/*
void OnRedBallDetection::check_position(){
    vector<float> ballPosition;
    float dist;
    int no_newData = 0;
    while(1){
      qi::os::msleep(50);
      if(ballProxy.isNewData()){
          no_newData = 0;
          ballPosition = ballProxy.getPosition();
          for(int i=0; i<ballPosition.size(); i++){
              cout<< ballPosition[i] << ",";
          }
          dist = sqrt(pow(ballPosition[0],2) + pow(ballPosition[1],2));
          cout << endl;
          if(ballPosition[1] > ballPosition[0]*0.2 || ballPosition[1] < -ballPosition[0]*0.2){
              turn(ballPosition[1]/(10*ballPosition[0]));
          }
          else{
              if(dist <= 0.22){
                stop();
              }
              else{
                moveToward(ballPosition[0], ballPosition[1]);
              }
          }
      }
      else{
          no_newData++;
          if(no_newData == 5){
              cout << "5stop" << endl;
              stop();
          }
      }
    }
}

void OnRedBallDetection::moveToward(float x, float y)
{
    float rad = atan(x/y);
    cout << "move" << endl;
    motionProxy.move(x/8, y/64, rad/24);
}

/// <summary> Walks using the moveTo command and shows odometry. </summary>
void OnRedBallDetection::turn(float angle)
{
    cout << "turn" << endl;
    motionProxy.move(0.0, 0.0, angle);
}

void OnRedBallDetection::stop(){
     cout << "stop" << endl;
     qi::os::msleep(2300);
     motionProxy.stopMove();
}*/

// void OnRedBallDetection::reachBall(){

//     //videoProxy.setActiveCamera(0);

//     ballProxy.setWholeBodyOn(false);
//     ballProxy.startTracker();


//     vector<float> ballPosition;
//     int no_newData = 0;

//     bool ballInRange = false;

//     while(!ballInRange){
//       qi::os::msleep(50);
//       if(ballProxy.isNewData()){
//           no_newData = 0;
//           ballPosition = ballProxy.getPosition();
//           for(int i=0; i<ballPosition.size(); i++){
//               cout<< ballPosition[i] << ",";
//           }

//           cout << endl;
//           ballInRange = walkToTarget(ballPosition[0], ballPosition[1]);
//       }
//       else{
//           no_newData++;
//           if(no_newData == 4){
//               no_newData = 0;
//               cout << "10stop" << endl;
//               stopMovement();
//           }
//       }
//     }
// }

// %%%%%%%%%%%%%%%%%%%%%%

// void OnRedBallDetection::reachBall(){

//     //videoProxy.setActiveCamera(0);

//     ballProxy.setWholeBodyOn(false);
//     ballProxy.startTracker();


//     vector<float> ballPosition;
//     int no_newData = 0;

//     bool ballInRange = false;

//     while(!ballInRange){
//       qi::os::msleep(50);
//       if(ballProxy.isNewData()){
//           no_newData = 0;
//           ballPosition = ballProxy.getPosition();
//           for(int i=0; i<ballPosition.size(); i++){
//               cout<< ballPosition[i] << ",";
//           }

//           cout << endl;
//           ballInRange = walkToTarget(ballPosition[0], ballPosition[1]);
//       }
//       else{
//           no_newData++;
//           if(no_newData == 4){
//               no_newData = 0;
//               cout << "10stop" << endl;
//               stopMovement();
//           }
//       }
//     }
// }
// bool OnRedBallDetection::walkToTarget(float x, float y)
// {
//     float targetDistance, targetAngle;
//     float velocityX, velocityTheta;
//     std::string posture;
//     float maxSpeedFraction;

//    // boost::shared_ptr<AL::ALRobotPostureProxy> posture_proxy =
//    // getParentBroker()->getSpecialisedProxy<AL::ALRobotPostureProxy>("ALRobotPosture");
//     std::string side = "Right";
// //    AL::ALValue names  = AL::ALValue::array("RHipRoll", "RHipPitch","RKneePitch","RAnklePitch","RAnkleRoll");
// //    AL::ALValue angles      = AL::ALValue::array(0.3f, -0.3f);
//  //   float fractionMaxSpeed  = 0.1f;
//     targetAngle = atan2(y, x);

//     // Parameters init.
//     velocityX = 0.0;
//     velocityTheta = 0.0;

//     cout << targetAngle*AL::Math::TO_DEG << endl;
   
//    //Control Feedback loop
//    // When the target angle is not in the fixed angle range [-17,17], change direction.
   
//         if( targetAngle > 17*AL::Math::TO_RAD){
//                velocityTheta = 0.25;
//     }
//     else if(targetAngle < -17*AL::Math::TO_RAD){
//                velocityTheta = -0.25;
//     }
//     else{
//        targetDistance = sqrt( pow(x,2) +  pow(y,2) );
//        // Setting 10 cm distance to target.
//       if (targetDistance >= 0.10)
//        {
//          velocityX = 0.9;
//        }
//        else{
//       // Final position reached. Stop. 
//                    velocityX = 0.0;
//        //          posture = "StandZero";
//        //          maxSpeedFraction = 0.2f;
//        //          posture_proxy->applyPosture(posture, maxSpeedFraction);
//                     //wbKick(side);
//                    cout << "Ball reached" << endl;

//        }

//     }
//     motionProxy.setWalkTargetVelocity(velocityX, 0, velocityTheta, 1);
//     cout << x << "," << y << endl;

//     if( x < 0.45 && y < 0.05 && y > -0.05){
//         if(ballCounter > 5){
//             ballCounter = 0;
//             return true;
//         }
//         else{
//             ballCounter++;
//             return false;
//         }
//     }
//     else{
//         ballCounter = 0;
//         return false;
//     }
// }
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


void OnRedBallDetection::wbKick(std::string side){


  int axisMask = 63; 
  int space = 2;

  float dx = 0.1f;
  float dz = 0.05f;
  float dwy = 5.0*AL::Math::TO_RAD;
  float duration = 2.0f;

  AL::ALValue times = AL::ALValue::array(1.0f, 1.7f, 2.3f);
  //AL::ALValue times = AL::ALValue::array(1.0f, 1.3f, 2.0f);
  bool isAbsolute = false;

  AL::ALValue targetList = AL::ALValue::array(
    AL::ALValue::array(-dx/1.7,0.0f,dz, 0.0f, +dwy/1.25, 0.0f),
    AL::ALValue::array(+dx/1.7,0.0f,dz, 0.0f, 0.0f, 0.0f),
    AL::ALValue::array(0.0f,0.0f,0.0f, 0.0f, 0.0f, 0.0f)
    );
  bool isEnabled = true;
  motionProxy.wbEnable(isEnabled);

  std::string stateName = "Fixed";
  std::string supportLeg = "Legs";
  motionProxy.wbFootState (stateName, supportLeg);

  if(side=="Left"){

      // Example showing how to Enable Effector Control as an Optimization.
  std::string effectorName = "LLeg";
  bool isActive = true;
  motionProxy.wbEnableEffectorOptimization(effectorName, isActive);

  supportLeg = "LLeg";
  motionProxy.wbGoToBalance(supportLeg, duration);

  stateName = "Free";
  supportLeg = "RLeg";
  motionProxy.wbFootState(stateName, supportLeg);

  effectorName = "RLeg";

  // Parameters: 
  //   chainName – Name of the chain. Could be: “Head”, “LArm”, “RArm”, “LLeg”, “RLeg”, “Torso”
  //   space – Task space {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
  //   path – Vector of 6D position arrays (x,y,z,wx,wy,wz) in meters and radians
  //   axisMask – Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
  //   durations – Vector of times in seconds corresponding to the path points
  //   isAbsolute – If true, the movement is absolute else relative
  

  motionProxy.positionInterpolation(effectorName, space, targetList,axisMask,times,isAbsolute);



  }
  else if (side == "Right"){
      std::string effectorName = "RLeg";
      bool isActive = false;
      motionProxy.wbEnableEffectorOptimization(effectorName,isActive);

      supportLeg = "RLeg";
      motionProxy.wbGoToBalance(supportLeg, duration);
      stateName = "Free";
      supportLeg = "LLeg";
      motionProxy.wbFootState(stateName,supportLeg);

      effectorName = "LLeg";
      motionProxy.positionInterpolation(effectorName,space,targetList,axisMask,times,isAbsolute);
  }
  qi::os::msleep(1000);
  isEnabled = false;
  motionProxy.wbEnable(isEnabled);
  poseInit();


}

void OnRedBallDetection::poseInit()
{

  boost::shared_ptr<AL::ALRobotPostureProxy> proxy = getParentBroker()->getSpecialisedProxy<AL::ALRobotPostureProxy>("ALRobotPosture");
  std::string posture = "StandInit";
  const float maxSpeedFraction = 0.2f;
  proxy->applyPosture(posture,maxSpeedFraction);
}

void OnRedBallDetection::stopMovement(){
     cout << "stop" << endl;
     qi::os::msleep(2300);
     motionProxy.stopMove();
}

