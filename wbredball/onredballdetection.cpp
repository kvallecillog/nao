/**
 *
 * Version : $Id$
 * This file was generated by Aldebaran Robotics ModuleGenerator
 */

#include "onredballdetection.h"

#include <alvalue/alvalue.h>
#include <alcommon/alproxy.h>
#include <alcommon/albroker.h>
#include <althread/alcriticalsection.h>
#include <vector>
#include <math.h>
#include <almath/tools/altrigonometry.h>


#include <alproxies/alrobotpostureproxy.h>
#include <alproxies/almotionproxy.h>

#include <qi/log.hpp>

using namespace std;

OnRedBallDetection::OnRedBallDetection(
    boost::shared_ptr<AL::ALBroker> broker,
    const std::string& name): AL::ALModule(broker, name),
    fMemoryProxy(getParentBroker()),
    ballCounter(0),
    motionProxy(getParentBroker()),
    ballProxy(getParentBroker()),
    fCallbackMutex(AL::ALMutex::createALMutex())
{
  setModuleDescription("Módulo para seguimiento de bola roja y translación del robot NAO");
}

OnRedBallDetection::~OnRedBallDetection() {
    ballProxy.stopTracker();

}

void OnRedBallDetection::init() {
    //boost::shared_ptr<AL::ALMotionProxy> proxy = getParentBroker()->getMotionProxy();

    // We use the "Body" name to signify the collection of all joints
    const std::string names = "Body";
    float stiffnessLists = 1.0f;
    float timeLists      = 1.0f;

    // the interpolation command will assume that the same value is desired
    // for all joints in the collection "Body"
    motionProxy.stiffnessInterpolation(names, stiffnessLists, timeLists);

    // Enable arm control by Walk algorithm
    motionProxy.setWalkArmsEnabled(true, true);

    // Enable FOOT CONTACT PROTECTION
    motionProxy.setMotionConfig(AL::ALValue::array(
       AL::ALValue::array("ENABLE_FOOT_CONTACT_PROTECTION", true)));

    // print motion state
    std::cout << motionProxy.getSummary() << std::endl;
    boost::shared_ptr<AL::ALRobotPostureProxy> posture_proxy =
        getParentBroker()->getSpecialisedProxy<AL::ALRobotPostureProxy>("ALRobotPosture");

    std::string posture = "Crouch";
    float maxSpeedFraction = 0.3f;

    posture_proxy->applyPosture(posture, maxSpeedFraction);

    posture = "StandZero";
    maxSpeedFraction = 0.2f;
    posture_proxy->applyPosture(posture, maxSpeedFraction);

    ballProxy.setWholeBodyOn(false);
    ballProxy.startTracker();

    while(1){
        reachBall();
    }

    //check_position();
}
/*
void OnRedBallDetection::check_position(){
    vector<float> ballPosition;
    float dist;
    int no_newData = 0;
    while(1){
      qi::os::msleep(50);
      if(ballProxy.isNewData()){
          no_newData = 0;
          ballPosition = ballProxy.getPosition();
          for(int i=0; i<ballPosition.size(); i++){
              cout<< ballPosition[i] << ",";
          }
          dist = sqrt(pow(ballPosition[0],2) + pow(ballPosition[1],2));
          cout << endl;
          if(ballPosition[1] > ballPosition[0]*0.2 || ballPosition[1] < -ballPosition[0]*0.2){
              turn(ballPosition[1]/(10*ballPosition[0]));
          }
          else{
              if(dist <= 0.22){
                stop();
              }
              else{
                moveToward(ballPosition[0], ballPosition[1]);
              }
          }
      }
      else{
          no_newData++;
          if(no_newData == 5){
              cout << "5stop" << endl;
              stop();
          }
      }
    }
}

void OnRedBallDetection::moveToward(float x, float y)
{
    float rad = atan(x/y);
    cout << "move" << endl;
    motionProxy.move(x/8, y/64, rad/24);
}

/// <summary> Walks using the moveTo command and shows odometry. </summary>
void OnRedBallDetection::turn(float angle)
{
    cout << "turn" << endl;
    motionProxy.move(0.0, 0.0, angle);
}

void OnRedBallDetection::stop(){
     cout << "stop" << endl;
     qi::os::msleep(2300);
     motionProxy.stopMove();
}*/

void OnRedBallDetection::reachBall(){

    //videoProxy.setActiveCamera(0);

    ballProxy.setWholeBodyOn(false);
    ballProxy.startTracker();


    vector<float> ballPosition;
    int no_newData = 0;

    bool ballInRange = false;

    while(!ballInRange){
      qi::os::msleep(50);
      if(ballProxy.isNewData()){
          no_newData = 0;
          ballPosition = ballProxy.getPosition();
          for(int i=0; i<ballPosition.size(); i++){
              cout<< ballPosition[i] << ",";
          }

          cout << endl;
          ballInRange = walkToTarget(ballPosition[0], ballPosition[1]);
      }
      else{
          no_newData++;
          if(no_newData == 4){
              no_newData = 0;
              cout << "10stop" << endl;
              stopMovement();
          }
      }
    }
}

bool OnRedBallDetection::walkToTarget(float x, float y)
{
    float targetDistance, targetAngle;
    float velocityX, velocityTheta;
    std::string posture;
    float maxSpeedFraction;

    boost::shared_ptr<AL::ALRobotPostureProxy> posture_proxy =
    getParentBroker()->getSpecialisedProxy<AL::ALRobotPostureProxy>("ALRobotPosture");

    targetAngle = atan2(y, x);

    // Parameters init.
    velocityX = 0.0;
    velocityTheta = 0.0;

    cout << targetAngle*AL::Math::TO_DEG << endl;
   
   //Control Feedback loop
   // When the target angle is not in the fixed angle range [-17,17], change direction.
   
        if( targetAngle > 17*AL::Math::TO_RAD){
               velocityTheta = 0.25;
    }
    else if(targetAngle < -17*AL::Math::TO_RAD){
               velocityTheta = -0.25;
    }
    else{
       targetDistance = sqrt( pow(x,2) +  pow(y,2) );
       // Setting 10 cm distance to target.
      if (targetDistance >= 0.8)
       {
         velocityX = 0.9;
       }
       else{
      // Final position reached. Stop. 
                   velocityX = 0.0;
                   posture = "StandZero";
                   maxSpeedFraction = 0.2f;
                   posture_proxy->applyPosture(posture, maxSpeedFraction);
                   cout << "Ball reached" << endl;
       }

    }
    motionProxy.setWalkTargetVelocity(velocityX, 0, velocityTheta, 1);
    cout << x << "," << y << endl;

    if( x < 0.45 && y < 0.05 && y > -0.05){
        if(ballCounter > 5){
            ballCounter = 0;
            return true;
        }
        else{
            ballCounter++;
            return false;
        }
    }
    else{
        ballCounter = 0;
        return false;
    }
}

void OnRedBallDetection::stopMovement(){
     cout << "stop" << endl;
     qi::os::msleep(2300);
     motionProxy.stopMove();
}

